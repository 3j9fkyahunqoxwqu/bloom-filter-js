{"version":3,"sources":["../../src/main.js"],"names":[],"mappings":"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","file":"main.js","sourcesContent":["import {toCharCodeArray, simpleHashFn, isBitSet, setBit} from './util.js';\n\nexport default class BloomFilter {\n  /**\n   * Constructs a new BloomFilter instance.\n   * If you'd like to initialize with a specific size just call BloomFilter.from(Array.from(Uint8Array(size).values()))\n   * Note that there is purposely no remove call because adding that would introduce false negatives.\n   *\n   * @param bitsPerElement Used along with estimatedNumberOfElements to figure out the size of the BloomFilter\n   *   By using 10 bits per element you'll have roughly 1% chance of false positives.\n   * @param estimatedNumberOfElements Used along with bitsPerElementto figure out the size of the BloomFilter\n   * @param hashFns An array of hash functions to use\n   *\n   */\n  constructor(bitsPerElement = 10, estimatedNumberOfElements = 50000, hashFns) {\n    if (bitsPerElement.constructor === Array) {\n      // Re-order params\n      let arrayLike = bitsPerElement;\n      if (estimatedNumberOfElements.constructor === Array) {\n        hashFns = estimatedNumberOfElements;\n      }\n      // Calculate new buffer size\n      this.bufferBitSize = arrayLike.length * 8;\n      this.buffer = new Uint8Array(arrayLike);\n    } else {\n      // Calculate the needed buffer size in bytes\n      this.bufferBitSize = bitsPerElement * estimatedNumberOfElements;\n      this.buffer = new Uint8Array(Math.ceil(this.bufferBitSize / 8));\n    }\n    this.hashFns = hashFns || [simpleHashFn(101), simpleHashFn(103), simpleHashFn(107)];\n    this.setBit = setBit.bind(this, this.buffer);\n    this.isBitSet = isBitSet.bind(this, this.buffer);\n  }\n\n\n  /**\n   * Construct a Bloom filter from a previous array of data\n   * Note that the hash functions must be the same!\n   */\n  static from(arrayLike, hashFns) {\n    return new BloomFilter(arrayLike, hashFns);\n  }\n\n  /**\n   * Serializing the current BloomFilter into a JSON friendly format.\n   * You would typically pass the result into JSON.stringify.\n   * Note that BloomFilter.from only works if the hash functions are the same.\n   */\n  toJSON() {\n    return Array.from(this.buffer.values());\n  }\n\n  /**\n   * Print the buffer, mostly used for debugging only\n   */\n  print() {\n    console.log(this.buffer);\n  }\n\n  /**\n   * Given a string gets all the locations to check/set in the buffer\n   * for that string\n   */\n  getLocationsForCharCodes(charCodes) {\n    return this.hashFns.map(h => h(charCodes) % this.bufferBitSize);\n  }\n\n  /**\n   * Adds he specified string to the set\n   */\n  add(data) {\n    if (data.constructor !== Array) {\n      data = toCharCodeArray(data);\n    }\n\n    this.getLocationsForCharCodes(data).forEach(this.setBit);\n  }\n\n  /**\n   * Checks whether an element probably exists in the set, or definitely doesn't.\n   * @param str Either a string to check for existance or an array of the string's char codes\n   *   The main reason why you'd want to pass in a char code array is because passing a string\n   *   will use JS directly to get the char codes which is very inneficient compared to calling\n   *   into C++ code to get it and then making the call.\n   *\n   * Returns true if the element probably exists in the set\n   * Returns false if the element definitely does not exist in the set\n   */\n  exists(data) {\n    if (data.constructor !== Array) {\n      data = toCharCodeArray(data);\n    }\n    return this.getLocationsForCharCodes(data).every(this.isBitSet);\n  }\n\n  /**\n   * Checks if any substring of length substringLenght probably exists or definitely doesn't\n   * If false is returned then no substring of the specified string of the specified lengthis in the bloom filter\n   * @param data The substring or char array to check substrings on.\n   */\n  substringExists(data, substringLength) {\n    if (data.constructor !== Array) {\n      data = toCharCodeArray(data);\n    }\n\n    for (let i = 0; i < data.length - substringLength + 1; i++) {\n      // TODO: We can optimize here by using a rolling hashing function\n      if (this.getLocationsForCharCodes(data.subarray(i, substringLength)).every(this.isBitSet)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n"]}