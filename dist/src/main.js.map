{"version":3,"sources":["../../src/main.js"],"names":[],"mappings":"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","file":"main.js","sourcesContent":["import {toCharCodeArray, simpleHashFn, isBitSet, setBit} from './util.js';\n\nexport default class BloomFilter {\n  /**\n   * Constructs a new BloomFilter instance.\n   * If you'd like to initialize with a specific size just call BloomFilter.from(Array.from(Uint8Array(size).values()))\n   * Note that there is purposely no remove call because adding that would introduce false negatives.\n   *\n   * @param bitsPerElement Used along with estimatedNumberOfElements to figure out the size of the BloomFilter\n   *   By using 10 bits per element you'll have roughly 1% chance of false positives.\n   * @param estimatedNumberOfElements Used along with bitsPerElementto figure out the size of the BloomFilter\n   * @param hashFns An array of hash functions to use. These can be custom but they should be of the form\n   *   (arrayValues, lastHash, lastCharCode) where the last 2 parameters are optional and are used to make\n   *   a rolling hash to save computation.\n   */\n  constructor(bitsPerElement = 10, estimatedNumberOfElements = 50000, hashFns) {\n    if (bitsPerElement.constructor === Array) {\n      // Re-order params\n      let arrayLike = bitsPerElement;\n      if (estimatedNumberOfElements.constructor === Array) {\n        hashFns = estimatedNumberOfElements;\n      }\n      // Calculate new buffer size\n      this.bufferBitSize = arrayLike.length * 8;\n      this.buffer = new Uint8Array(arrayLike);\n    } else {\n      // Calculate the needed buffer size in bytes\n      this.bufferBitSize = bitsPerElement * estimatedNumberOfElements;\n      this.buffer = new Uint8Array(Math.ceil(this.bufferBitSize / 8));\n    }\n    this.hashFns = hashFns || [simpleHashFn(101), simpleHashFn(103), simpleHashFn(107)];\n    this.setBit = setBit.bind(this, this.buffer);\n    this.isBitSet = isBitSet.bind(this, this.buffer);\n  }\n\n\n  /**\n   * Construct a Bloom filter from a previous array of data\n   * Note that the hash functions must be the same!\n   */\n  static from(arrayLike, hashFns) {\n    return new BloomFilter(arrayLike, hashFns);\n  }\n\n  /**\n   * Serializing the current BloomFilter into a JSON friendly format.\n   * You would typically pass the result into JSON.stringify.\n   * Note that BloomFilter.from only works if the hash functions are the same.\n   */\n  toJSON() {\n    return Array.from(this.buffer.values());\n  }\n\n  /**\n   * Print the buffer, mostly used for debugging only\n   */\n  print() {\n    console.log(this.buffer);\n  }\n\n  /**\n   * Given a string gets all the locations to check/set in the buffer\n   * for that string.\n   * @param charCodes An array of the char codes to use for the hash\n   */\n  getLocationsForCharCodes(charCodes) {\n    return this.hashFns.map(h => h(charCodes) % this.bufferBitSize);\n  }\n\n  /**\n   * Obtains the hashes for the specified charCodes\n   * See \"Rabin fingerprint\" in https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm for more information.\n   *\n   * @param charCodes An array of the char codes to use for the hash\n   * @param lastHashes If specified, it will pass the last hash to the hashing\n   * function for a faster computation.  Must be called with lastCharCode.\n   * @param lastCharCode if specified, it will pass the last char code\n   *  to the hashing function for a faster computation. Must be called with lastHashes.\n   */\n  getHashesForCharCodes(charCodes, lastHashes, lastCharCode) {\n    return this.hashFns.map((h, i) => h(charCodes, lastHashes ? lastHashes[i] : undefined, lastCharCode));\n  }\n\n  /**\n   * Adds he specified string to the set\n   */\n  add(data) {\n    if (data.constructor !== Array) {\n      data = toCharCodeArray(data);\n    }\n\n    this.getLocationsForCharCodes(data).forEach(this.setBit);\n  }\n\n  /**\n   * Checks whether an element probably exists in the set, or definitely doesn't.\n   * @param str Either a string to check for existance or an array of the string's char codes\n   *   The main reason why you'd want to pass in a char code array is because passing a string\n   *   will use JS directly to get the char codes which is very inneficient compared to calling\n   *   into C++ code to get it and then making the call.\n   *\n   * Returns true if the element probably exists in the set\n   * Returns false if the element definitely does not exist in the set\n   */\n  exists(data) {\n    if (data.constructor !== Array) {\n      data = toCharCodeArray(data);\n    }\n    return this.getLocationsForCharCodes(data).every(this.isBitSet);\n  }\n\n  /**\n   * Checks if any substring of length substringLenght probably exists or definitely doesn't\n   * If false is returned then no substring of the specified string of the specified lengthis in the bloom filter\n   * @param data The substring or char array to check substrings on.\n   */\n  substringExists(data, substringLength) {\n    if (data.constructor !== Uint8Array) {\n      if (data.constructor !== Array) {\n        data = toCharCodeArray(data);\n      }\n      data = new Uint8Array(data);\n    }\n\n    let lastHashes, lastCharCode;\n    for (let i = 0; i < data.length - substringLength + 1; i++) {\n\n      lastHashes = this.getHashesForCharCodes(data.subarray(i, i + substringLength), lastHashes, lastCharCode);\n      if (lastHashes.map(x => x % this.bufferBitSize).every(this.isBitSet)) {\n        return true;\n      }\n      lastCharCode = data[i];\n    }\n    return false;\n  }\n}\n"]}